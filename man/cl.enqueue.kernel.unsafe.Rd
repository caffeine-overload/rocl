% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rcl.r
\name{cl.enqueue.kernel.unsafe}
\alias{cl.enqueue.kernel.unsafe}
\title{Execute an OpenCL kernel with less overhead}
\usage{
cl.enqueue.kernel.unsafe(queue, kernel, dimensions, global_work_size,
  arguments, local_work_size = NULL, global_work_offset,
  waitlist = NULL, return_event = NULL)
}
\arguments{
\item{queue}{An opencl_command_queue object. The queue the operation will be put on.}

\item{kernel}{The kernel to execute. An opencl_kernel object}

\item{dimensions}{The dimensions of the kernel}

\item{global_work_size}{The number of global threads in each dimension}

\item{arguments}{A list of kernel arguments. Must be all opencl_buffer objects. Any names are ignored, the arguments
are passed by position.}

\item{local_work_size}{The number of local threads in each dimension inside a work-group. If left NULL, the OpenCL runtime will pick a value.}

\item{global_work_offset}{The starting offset of the global thread ids in each dimension.}

\item{waitlist}{OpenCL events that must complete before this operation can start.
Not currently used, included for future use.}

\item{return_event}{Schedule the kernel asynchronously and return an opencl event object.
Not currently used, included for future use.}
}
\description{
Just like cl.enqueue.kernel, but without expensive calls to stopifnot.
}
\details{
cl.enqueue.kernel makes calls to stopifnot to ensure the types of arguments. This introduces significant overhead,
so this function is without any type-checking, at the risk of crashing R if the wrong types are given. Note that
global_work_offset is mandatory here.
}
